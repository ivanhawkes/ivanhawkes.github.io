<!doctype html><html>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=apple-touch-icon href=/img/apple-icon.png>
<link rel=icon href=/img/favicon.png>
<title>Life Reboot</title>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="First Person and Action RPG Cameras">
<meta name=twitter:description content="Handling input and camera management.">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">
<div class=container-fluid>
<a class=navbar-brand href=https://ivanhawkes.github.io/>Ivan Hawkes</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<div class="collapse navbar-collapse" id=navbarSupportedContent>
<ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class=nav-item>
<a href=https://ivanhawkes.github.io/post class="nav-link d-flex align-items-center">
<i class=bi-stickies></i>&#160;Posts
</a>
</li>
<li class=nav-item>
<a href=https://ivanhawkes.github.io/project class="nav-link d-flex align-items-center">
<i class=bi-kanban></i>&#160;Our Projects
</a>
</li>
<li class=nav-item>
<a href=https://ivanhawkes.github.io/profile class="nav-link d-flex align-items-center">
<i class=bi-file-earmark-person></i>&#160;Our Team
</a>
</li>
<li class=nav-item>
<a href=https://ivanhawkes.github.io/recipe class="nav-link d-flex align-items-center">
<i class=bi-egg-fried></i>&#160;Recipes
</a>
</li>
<li class=nav-item>
<a href=https://ivanhawkes.github.io/garden class="nav-link d-flex align-items-center">
<i class=bi-tree></i>&#160;Garden
</a>
</li>
<li class=nav-item>
<a href=https://ivanhawkes.github.io/plant class="nav-link d-flex align-items-center">
<i class=bi-flower1></i>&#160;Plants
</a>
</li>
<li class=nav-item>
<a href=https://ivanhawkes.github.io/about class="nav-link d-flex align-items-center">
<i class=bi-person-lines-fill></i>&#160;About Us
</a>
</li>
</ul>
</div>
</div>
</nav>
<div class=container>
<div class=container>
<div class=row>
<div class="col text-center">
<h1>First Person and Action RPG Cameras</h1>
<div class=card>
<div class="card-header card-header-image">
<a href=#pablo>
<img src=/img/site/category/cryengine.jpg class=card-img-top alt>
</a>
<div class=colored-shadow style=background-image:url(/img/site/category/cryengine.jpg);opacity:1></div>
</div>
<div class=card-body>
<p class=text-start></p>
</div>
</div>
</div>
</div>
<div class=row>
<div class=col-12>
<hr>
</div>
</div>
<div class=row>
<div class=col-6>
<p class=h6>
By Ivan Hawkes<br>September 14, 2016
</p>
</div>
<div class="col-6 text-end">
<a href="https://www.facebook.com/sharer/sharer.php?u=ivan.hawkes" class=btn target=_blank>
<i class=bi-facebook style=font-size:32px></i>
</a>
<a href="https://twitter.com/intent/tweet?url=%40ivanhawkes" class=btn target=_blank>
<i class=bi-twitter style=font-size:32px></i>
</a>
<a href="https://www.linkedin.com/shareArticle?mini=true&url=ivan-hawkes-a8386338" class=btn target=_blank>
<i class=bi-linkedin style=font-size:32px></i></a>
<a href="http://www.pinterest.com/pin/find/?url=ivanhawkes" class=btn target=_blank>
<i class=bi-pinterest style=font-size:32px></i></a>
</div>
</div>
<div class=row>
<div class=col-12>
<hr>
</div>
</div>
<div class=row>
<div class=col>
<p>In this article I will introduce you to view management within CRYENGINE and then use the existing view management to build a camera manager, a first person camera and a third person orbit camera (action RPG style).</p>
<p>The first person camera is simple enough, but the third person camera has a few nice features above and beyond the one available in the new c++ game templates from <a href=http://crytek.com/>CryTek</a>.</p>
<p>The code will be available in my <a href=https://github.com/ivanhawkes/Chrysalis/tree/camera_code_article>GitHub repository</a> with a tag specific to the code being discussed in the article. There&rsquo;s a lot of other things in there which you might want to poke through, but be aware it&rsquo;s a work in progress and is definitely not production ready.</p>
<p>The manager is not strictly necessary at this point, and is definitely overkill for just flipping between a pair of cameras, but it will come into it&rsquo;s own later down the track when more camera types are added.</p>
<p>You can see a very simple demo of the camera in action on my <a href=https://youtu.be/lX4KiZly0oY>YouTube page</a>.</p>
<p>So, let&rsquo;s kick off; a camera manager and a pair of cameras for CRYENGINE 5.2.</p>
<h2 id=no-vacuum>No Vacuum</h2>
<p>It&rsquo;s worth mentioning straight up that no code exists in a vacuum. A camera is a pretty low level section of code but it still relies on the player input routines, and it may need some information from the player as well.</p>
<p>Contrary to the current camera implementations in the new c++ game templates, this camera manager and the cameras do not assume they are strictly for use with the player entity. My long term goal is a game where the players will be able to switch at will between several characters who stay persistently in the game world. In order to support this the cameras are going to &ldquo;attach&rdquo; themselves to an entity, and use that as a base to pitch, yaw and roll around.</p>
<p>The attachment part is actually pretty generic, so we are able to attach this camera implementation to any entity - though it performs best with ones that have a skeleton, and bones with well-known names. For simplicity I have limited them to attaching only to an <strong>IActor</strong> based entity, since I want to take advantage of the ability to query the actor skeleton for the position of the eyes.</p>
<h2 id=player-input>Player Input</h2>
<p>Our first stop is a visit to the player input code, which you can find in the <strong>/Player/Input</strong> folder of the project. Since the camera is likely to share some inputs with other parts of the game, in particular mouse movements, there is some dependant code in the player input system.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>/**
</span><span style=color:#75715e>Given the current input state, calculate an angular vector that represents the rotation the player has requested
</span><span style=color:#75715e>using the mouse / xbox controller / etc.
</span><span style=color:#75715e>
</span><span style=color:#75715e>This is typically used to rotate the character and the camera.
</span><span style=color:#75715e>
</span><span style=color:#75715e>\return The rotation.
</span><span style=color:#75715e>**/</span>
<span style=color:#66d9ef>virtual</span> Ang3 <span style=color:#a6e22e>GetRotationDelta</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>/**
</span><span style=color:#75715e>Gets pitch delta.
</span><span style=color:#75715e>
</span><span style=color:#75715e>\return The pitch delta.
</span><span style=color:#75715e>**/</span>
<span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>GetPitchDelta</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>/**
</span><span style=color:#75715e>Gets yaw delta.
</span><span style=color:#75715e>
</span><span style=color:#75715e>\return The yaw delta.
</span><span style=color:#75715e>**/</span>
<span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>GetYawDelta</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>/**
</span><span style=color:#75715e>Gets number of times the player has requested a change in zoom level since the last frame. Cameras can query this
</span><span style=color:#75715e>value and use it to adjust their zoom.
</span><span style=color:#75715e>
</span><span style=color:#75715e>\return The zoom delta.
</span><span style=color:#75715e>**/</span>
<span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>GetZoomDelta</span> () <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</code></pre></div><p>Just a small handful of functions will be needed by our camera. <strong>GetRotationDelta</strong>, <strong>GetPitchDelta</strong>, and <strong>GetYawDelta</strong> will provide the delta in yaw, pitch and roll for this frame, allowing us to change the direction the camera is facing in lock-step with movement and turning requests from the player. <strong>GetZoomDelta</strong> returns a float that indicates how many steps in or out the camera zoom has been adjusted during this frame. Together, they provide everything needed to smoothly pan a camera around an orbit point with a variable zoom distance that the player can adjust during gameplay.</p>
<h2 id=the-camera-manager>The Camera Manager</h2>
<p>The camera manager is the fairly simple beating heart of the camera system. It will be responsible for creating instances of each camera type, and allowing for a means of selecting and changing cameras. It&rsquo;s also a convenient place for us to declare a few debug cvars. The manager will written as an extension that is acquired by the player entity during <strong>CPlayer::PostInit</strong>. The code is shown in it&rsquo;s entirety below for reference.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> CPlayer<span style=color:#f92672>::</span>PostInit(IGameObject <span style=color:#f92672>*</span> pGameObject)
{
	<span style=color:#75715e>// Registers this instance to the actor system.
</span><span style=color:#75715e></span>	gEnv<span style=color:#f92672>-&gt;</span>pGame<span style=color:#f92672>-&gt;</span>GetIGameFramework()<span style=color:#f92672>-&gt;</span>GetIActorSystem()<span style=color:#f92672>-&gt;</span>AddActor(GetEntityId(), <span style=color:#66d9ef>this</span>);

	<span style=color:#75715e>// Create a camera manager for this player. We do this early, since character attachment code needs to make calls
</span><span style=color:#75715e></span>	<span style=color:#75715e>// to a functioning camera.
</span><span style=color:#75715e></span>	m_pCameraManager <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>ICameraManagerComponent<span style=color:#f92672>*&gt;</span> (GetGameObject()<span style=color:#f92672>-&gt;</span>AcquireExtension(<span style=color:#e6db74>&#34;CameraManager&#34;</span>));

	<span style=color:#75715e>// Acquire a player input component. At a later time it will be useful to check if a network version is needed, or
</span><span style=color:#75715e></span>	<span style=color:#75715e>// perhaps AI / NULL versions.
</span><span style=color:#75715e></span>	m_pPlayerInput <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>IPlayerInputComponent<span style=color:#f92672>*&gt;</span> (GetGameObject()<span style=color:#f92672>-&gt;</span>AcquireExtension(<span style=color:#e6db74>&#34;PlayerInput&#34;</span>));

	<span style=color:#75715e>// HACK: hard coded effort to grab an entity to attach to as our pawn / character. It must occur after the camera has a chance to create itself.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>auto</span> pCharacterEntity <span style=color:#f92672>=</span> gEnv<span style=color:#f92672>-&gt;</span>pEntitySystem<span style=color:#f92672>-&gt;</span>FindEntityByName(<span style=color:#e6db74>&#34;Character1&#34;</span>);
	CRY_ASSERT_MESSAGE(pCharacterEntity, <span style=color:#e6db74>&#34;Player is not attached to a character. Do not enter game mode without attaching to a character.&#34;</span>);
	<span style=color:#66d9ef>if</span> (pCharacterEntity)
	AttachToCharacter(pCharacterEntity<span style=color:#f92672>-&gt;</span>GetId());

	<span style=color:#75715e>// Register for game object events.
</span><span style=color:#75715e></span>	RegisterForGOEvents();
}
</code></pre></div><p>The astute will notice my dirty <strong>hack</strong> in that code. Since it is still very early in development for <strong>Chrysalis</strong> I am hard coding a hack to immediately attach to an entity called &ldquo;Character1&rdquo; if it exists. Character1 is an instance of the <strong>CCharacter</strong> class - which is an <strong>IActor</strong> extension and will be the basis for all characters in the game, playable or NPC. It is doubtful anyone else&rsquo;s game will need this line of code.</p>
<h2 id=icameramanagercomponent>ICameraManagerComponent</h2>
<p>Camera&rsquo;s tend to be bound to the player, rather than a specific character. It is the player who presses the buttons that control the camera. It is the player&rsquo;s point of view that changes as you rotate around a character.</p>
<p>In this project, we will allow the player to attach and detach from characters / actors at will. The project design is intentionally flexible, with the goal of being able to control any character inside the game. This means the player, who is normally the focus of a camera instead acts as a proxy, directing focus to where the camera is really meant to be - the character the player is presently controlling.</p>
<p>Let&rsquo;s take a look at the code, but first&mldr;</p>
<p>When I am trying to define a new piece of functionality I usually like to start with an interface to get to the core of the requirement. Once that is well defined I will tend to write one or more concrete examples of the interface.</p>
<p>We&rsquo;ll start with the interface for the camera manager, since it cuts to the heart of what the component does.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#pragma once
</span><span style=color:#75715e></span>
<span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;ICameraComponent.h&#34;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ICameraComponent</span>;

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ICameraManagerComponent</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> ISimpleExtension
{
<span style=color:#75715e>/**
</span><span style=color:#75715e>Player cameras generally need to follow an actor. This allows us to switch which entity represents the actor that
</span><span style=color:#75715e>the camera is following. The presently in-use camera is instructed to follow the supplied entity.
</span><span style=color:#75715e>
</span><span style=color:#75715e>\param entityID If non-null, the entity.
</span><span style=color:#75715e>**/</span>
<span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AttachToEntity</span>(EntityId entityID) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>/**
</span><span style=color:#75715e>Gets current camera mode.
</span><span style=color:#75715e>
</span><span style=color:#75715e>\return The current camera mode.
</span><span style=color:#75715e>**/</span>
<span style=color:#66d9ef>virtual</span> ECameraMode <span style=color:#a6e22e>GetCameraMode</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>/**
</span><span style=color:#75715e>Sets camera mode.
</span><span style=color:#75715e>
</span><span style=color:#75715e>\param mode The mode.
</span><span style=color:#75715e>\param reason The reason.
</span><span style=color:#75715e>**/</span>
<span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SetCameraMode</span>(ECameraMode mode, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> reason) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>/**
</span><span style=color:#75715e>Gets the currently active camera.
</span><span style=color:#75715e>
</span><span style=color:#75715e>\return null if it fails, else the camera.
</span><span style=color:#75715e>**/</span>
<span style=color:#66d9ef>virtual</span> ICameraComponent<span style=color:#f92672>*</span> <span style=color:#a6e22e>GetCamera</span>() <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>/**
</span><span style=color:#75715e>The camera manager may supply an extra offset in local space for camera adjustments to the view.
</span><span style=color:#75715e>
</span><span style=color:#75715e>\return The view offset.
</span><span style=color:#75715e>**/</span>
<span style=color:#66d9ef>virtual</span> Vec3 <span style=color:#a6e22e>GetViewOffset</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>/**
</span><span style=color:#75715e>Gets whether this instance is in third person or not.
</span><span style=color:#75715e>
</span><span style=color:#75715e>\return Whether this instance is in third person or not.
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>IsThirdPerson</span>() <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#75715e>/**
</span><span style=color:#75715e>Toggles third person mode of this instance (typically meant to toggle between third person and first person models and cameras).
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ToggleThirdPerson</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
};
</code></pre></div><p>The code is pretty simple, and the comments should explain it fairly well. In summary, the manager will provide a means to attach the camera(s) to an entity using the <strong>AttachToEntity</strong> function. <strong>SetCameraMode</strong> allows you to request the manager switches to a new camera mode, selected from the enumeration defined by <strong>ECameraMode</strong>. You would extend this enumeration when adding new types of cameras to the system.</p>
<p><strong>GetCamera</strong> allows the game to query for a camera, returning an <strong>ICameraComponent</strong>* for the camera that is currently in use. The game can check this structure for the camera position, rotation, aim target and other factors - in a polymorphic manner. It needed worry about which camera is presently in use, since all will provide that interface at a minimum.</p>
<p>One problem when dealing with camera code is that it&rsquo;s often impossible to see where the camera is located, and that can make it hard to debug - especially when developing new cameras. To get around that the camera manager can be queried for an offset by calling <strong>GetViewOffset.</strong> That offset can and should be applied to the camera view after all other transformations have been applied. Being able to slide the final view back a metre can be very illustrative.</p>
<p>Finally, the pair of functions, <strong>IsThirdPerson</strong> and <strong>ToggleThirdPerson</strong> are meant to track whether the camera is in third person mode or not. I still haven&rsquo;t settled on whose responsibility it is to track third person mode for my game, since <strong>CPlayer</strong> and <strong>CCharacter</strong> both need to support it. I am hedging my bets and making the camera manager the sole agent responsible to handling this issue.</p>
<p>Now it&rsquo;s time to see what makes the camera manager tick.</p>
<h2 id=ccameramanagercomponent>CCameraManagerComponent</h2>
<p>The header file for CCameraManagerComponent is mostly just the same filler code you should have seen multiple times in the c++ game templates. There&rsquo;s only a couple of noteworthy things; the first being that we are ultimately derived from ISimpleExtension - which takes a lot of the boilerplate code out of the project. The second is that we also derive from <strong>IActionListener</strong> meaning the code is going to enable some actions from the action map and listen for action events.</p>
<p>That&rsquo;s as simple as declaring a pair of functions and implementing them in the cpp file.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>/**
</span><span style=color:#75715e>Handles the action event.
</span><span style=color:#75715e>
</span><span style=color:#75715e>\param action The action.
</span><span style=color:#75715e>\param activationMode The activation mode.
</span><span style=color:#75715e>\param value An optional value that may contain useful information for an action.
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>OnAction</span>(<span style=color:#66d9ef>const</span> ActionId<span style=color:#f92672>&amp;</span> action, <span style=color:#66d9ef>int</span> activationMode, <span style=color:#66d9ef>float</span> value);

<span style=color:#75715e>/** After action. */</span>
<span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AfterAction</span>() {};
</code></pre></div><p>Of course, it&rsquo;s useful for those commands to also do something - so later on the code declares a bunch of functions which will be called by the action handler - and an instance of the action handler itself.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>/** Registers the action maps and starts to listen for action map events. */</span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>RegisterActionMaps</span>();

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>InitializeActionHandler</span>();

<span style=color:#75715e>/** Executes the camera shift up action. **/</span>
<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>OnActionCameraShiftUp</span>(EntityId entityId, <span style=color:#66d9ef>const</span> ActionId<span style=color:#f92672>&amp;</span> actionId, <span style=color:#66d9ef>int</span> activationMode, <span style=color:#66d9ef>float</span> value);

<span style=color:#75715e>/** Executes the camera shift down action. **/</span>
<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>OnActionCameraShiftDown</span>(EntityId entityId, <span style=color:#66d9ef>const</span> ActionId<span style=color:#f92672>&amp;</span> actionId, <span style=color:#66d9ef>int</span> activationMode, <span style=color:#66d9ef>float</span> value);

<span style=color:#75715e>/** Executes the camera shift left action. **/</span>
<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>OnActionCameraShiftLeft</span>(EntityId entityId, <span style=color:#66d9ef>const</span> ActionId<span style=color:#f92672>&amp;</span> actionId, <span style=color:#66d9ef>int</span> activationMode, <span style=color:#66d9ef>float</span> value);

<span style=color:#75715e>/** Executes the camera shift right action. **/</span>
<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>OnActionCameraShiftRight</span>(EntityId entityId, <span style=color:#66d9ef>const</span> ActionId<span style=color:#f92672>&amp;</span> actionId, <span style=color:#66d9ef>int</span> activationMode, <span style=color:#66d9ef>float</span> value);

<span style=color:#75715e>/** Executes the camera shift forward action. **/</span>
<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>OnActionCameraShiftForward</span>(EntityId entityId, <span style=color:#66d9ef>const</span> ActionId<span style=color:#f92672>&amp;</span> actionId, <span style=color:#66d9ef>int</span> activationMode, <span style=color:#66d9ef>float</span> value);

<span style=color:#75715e>/** Executes the camera shift backward action. **/</span>
<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>OnActionCameraShiftBackward</span>(EntityId entityId, <span style=color:#66d9ef>const</span> ActionId<span style=color:#f92672>&amp;</span> actionId, <span style=color:#66d9ef>int</span> activationMode, <span style=color:#66d9ef>float</span> value);

<span style=color:#75715e>/** A static handler for the actions we are interested in hooking. */</span>
TActionHandler<span style=color:#f92672>&lt;</span>CCameraManagerComponent<span style=color:#f92672>&gt;</span> m_actionHandler;
</code></pre></div><p>There&rsquo;s nothing terribly interesting happening there; it&rsquo;s just providing a pair of actions for each axis to track camera movements for the view offset. That&rsquo;s really only needed for debugging, so you could remove it from release builds or chose to not even include it to begin with.</p>
<p>Peering inside <strong>CameraManagerComponent.cpp</strong> you can see in the <strong>PostInit</strong> function the code to clean out an array of cameras and load one of each type into that array. It also makes a quick check to see if we should be in first or third person mode.</p>
<p>You might at this point be wondering why I went to the trouble of making each camera a game extension / component. It doesn&rsquo;t add a lot of value, if any for the first and third person cameras since they are fixed to the player / attached actor and won&rsquo;t be used anywhere else in the game as entities. It simply makes no sense for those cameras to be used in any other place.</p>
<p>However, if you examine the <strong>GameSDK</strong> code you will see they actually have implementations for perhaps 12 different cameras, used in all sorts of circumstances e.g. death camera, pursuit camera, vehicle camera, static camera and animation controlled cameras. It is almost certain that at some point I will be adding several of those camera types into the game, and placing them as entities. Being able to use the same code for all the cameras is just good sense. The manager will eventually be able to deal with all the different cameras, so they need to use a common interface, and a game extension with <strong>ICamera</strong> on top is perfect for that.</p>
<p>Jumping back to the code, the <strong>Update</strong> function is pretty dull. It&rsquo;s just looking to see if the cvar for third person mode changed and flipping states and cameras if needed. In <strong>HandleEvent</strong> we are just waiting to see if we become the local player. This should in fact happen since the camera manager is going to be acquired by the player entity, and that entity will receive the <strong>eGFE_BecomeLocalPlayer</strong> event. We&rsquo;re taking advantage of that to register the action maps.</p>
<p>The implementation of <strong>AttachToEntity</strong> is pretty simple and isn&rsquo;t even checking the entity exists It&rsquo;s notifying each camera type that we are now attached to a new entity.</p>
<p>I could have written it so each camera would query the camera manager for the entityId they are attached to each frame, but decided it would be better to have an explicit event and store the Id in each camera. This would give cameras that needed it a chance to perform some init code when switching entities - at a cost of each storing a small amount of redundant data.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> CCameraManagerComponent<span style=color:#f92672>::</span>AttachToEntity(EntityId entityID)
{
	<span style=color:#75715e>// Let all the cameras know we switch entities. Only a few will care, but it&#39;s safer to just let them all handle
</span><span style=color:#75715e></span>	<span style=color:#75715e>// it. An alternative would be to perform an attach when switching cameras. This is good enough for now. 
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ECameraMode<span style=color:#f92672>::</span>eCameraMode_Last; <span style=color:#f92672>++</span>i)
	{
		<span style=color:#66d9ef>if</span> (m_cameraModes [i])
		m_cameraModes [i]<span style=color:#f92672>-&gt;</span>AttachToEntity(entityID);
	}
}
</code></pre></div><p>When it&rsquo;s time to change camera modes we need to do a little dance.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> CCameraManagerComponent<span style=color:#f92672>::</span>SetCameraMode(ECameraMode mode, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> reason)
{
	<span style=color:#66d9ef>if</span> (m_cameraMode <span style=color:#f92672>!=</span> mode)
	{
		<span style=color:#75715e>// Tell the previous camera it&#39;s no longer in use.
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> (m_cameraMode <span style=color:#f92672>!=</span> ECameraMode<span style=color:#f92672>::</span>eCameraMode_NoCamera)
			m_cameraModes [m_cameraMode]<span style=color:#f92672>-&gt;</span>OnDeactivate();

		<span style=color:#75715e>// Tell the new camera it is entering usage.
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> (mode <span style=color:#f92672>!=</span> ECameraMode<span style=color:#f92672>::</span>eCameraMode_NoCamera)
			m_cameraModes [mode]<span style=color:#f92672>-&gt;</span>OnActivate();

		<span style=color:#75715e>// Track the previous camera mode, in case we want to switch back to it.
</span><span style=color:#75715e></span>		m_lastCameraMode <span style=color:#f92672>=</span> m_cameraMode;

		<span style=color:#75715e>// Set the new mode.
</span><span style=color:#75715e></span>		m_cameraMode <span style=color:#f92672>=</span> mode;

		<span style=color:#75715e>// Forced changes to mode here should toggle third person if appropriate.
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>switch</span> (m_cameraMode)
		{
		<span style=color:#66d9ef>case</span> ECameraMode<span style=color:#f92672>::</span>eCameraMode_ActionRpg:
			SetCVars().m_isThirdPerson <span style=color:#f92672>=</span> true;
			<span style=color:#66d9ef>break</span>;

		<span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
			SetCVars().m_isThirdPerson <span style=color:#f92672>=</span> false;
			<span style=color:#66d9ef>break</span>;
		}

		<span style=color:#75715e>// Debug.
</span><span style=color:#75715e></span>		CryLogAlways(<span style=color:#e6db74>&#34;SetCameraMode from %d to %d, reason - %s&#34;</span>, m_lastCameraMode, m_cameraMode, reason);
	}
	<span style=color:#66d9ef>else</span>
	{
		<span style=color:#75715e>// Debug.
</span><span style=color:#75715e></span>		CryLogAlways(<span style=color:#e6db74>&#34;SetCameraMode from %d to %d, reason - %s (Skipped)&#34;</span>, m_lastCameraMode, m_cameraMode, reason);
	}
}
</code></pre></div><p>The old camera needs to be told it&rsquo;s no longer in use, and the new camera needs to be told it&rsquo;s now the active camera. The cameras themselves know what needs to be done at these times and we can examine that in a little while.</p>
<p>We&rsquo;re tracking the last camera in use, although if you check, you&rsquo;ll see that I don&rsquo;t do anything with this yet. The idea of that variable is so game code can request a special camera, say the death camera, and then flip back to the last used camera once the death scene is complete.</p>
<p>The final noteworthy code there is just trying to decide if it should use the first or third person cameras when a camera switch is requested. Because the player can toggle and flip between them, they are treated as a pair, and the manager will need to decide which to use based on the cvar, and perhaps player / character choice.</p>
<p>That switch statement isn&rsquo;t doing much right now, but as new cameras are added it will be extended to allow switching to them.</p>
<p>Finally, in there is some code for enabling action maps and actions, and releasing them on destruction. That should be familiar enough to not require coverage here.</p>
<p>One thing I did notice though, was having two different extensions on the same entity both requesting and using action maps doesn&rsquo;t seem to be something CryTek coded for and I did have issues with one or the other failing in a poorly behaved way. If you run into this then think about just moving all the input into a single player input routine and dispatching events from there.</p>
<h2 id=cfirstpersoncameracomponent>CFirstPersonCameraComponent</h2>
<p>You&rsquo;ve made it this far through the endless pre-amble, but before we get to the interesting camera we need to discuss the fairly simple first person camera.</p>
<p>As with all cameras in the system it&rsquo;s based on <strong>ICamera</strong>, which is in turn based on <strong>ISimpleExtension</strong>. This does mean you could allow this camera to be registered and visible in the editor if you wanted - it&rsquo;s just not particularly useful for this sort of camera. The good news, of course, is that it would be dead simple to copy this code to a new component and expose that as say a static security camera - or whatever.</p>
<p>The camera declares a few variables and the virtual functions it provides overrides for. We&rsquo;re keeping a track of the camera manager with <strong>m_pCameraManager</strong> and the target entity with <strong>m_targetEntityID</strong>. The view is held in <strong>m_pView</strong>, and is an instance of the <strong>IView</strong>* class provided in the CRYENGINE core code. We only have one camera specific variable, <strong>m_viewPitch</strong>, and that is just going to track camera rotation movement requests from the player input system.</p>
<p>In the PostInit function we need to take care of a little setup.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> CFirstPersonCameraComponent<span style=color:#f92672>::</span>PostInit(IGameObject <span style=color:#f92672>*</span> pGameObject)
{
	<span style=color:#75715e>// It&#39;s a good idea to use the entity as a default for our target entity.
</span><span style=color:#75715e></span>	m_targetEntityID <span style=color:#f92672>=</span> GetEntityId();

	<span style=color:#75715e>// Create a new view and link it to this entity.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>auto</span> pViewSystem <span style=color:#f92672>=</span> gEnv<span style=color:#f92672>-&gt;</span>pGame<span style=color:#f92672>-&gt;</span>GetIGameFramework()<span style=color:#f92672>-&gt;</span>GetIViewSystem();
	m_pView <span style=color:#f92672>=</span> pViewSystem<span style=color:#f92672>-&gt;</span>CreateView();
	m_pView<span style=color:#f92672>-&gt;</span>LinkTo(GetGameObject());

	<span style=color:#75715e>// We are usually hosted in the same entity as a camera manager. Use it if you can find one.
</span><span style=color:#75715e></span>	m_pCameraManager <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>ICameraManagerComponent<span style=color:#f92672>*&gt;</span> (pGameObject<span style=color:#f92672>-&gt;</span>QueryExtension(<span style=color:#e6db74>&#34;CameraManager&#34;</span>));
}
</code></pre></div><p>To make this camera a little more useful to other projects it will default to targeting the entity which hosts this extension. That&rsquo;s usually going to be the player entity. You could remove references to the camera manager and just use this code (mostly as-is) as a first person camera which the player code acquires directly in PostInit.</p>
<p>Next, the code does two things. It stores a reference to the camera manager for later use to save running that query every frame. Before it does that it queries the game framework for the view system and creates a new view, then links that view to the game object.</p>
<h3 id=the-view-system>The View System</h3>
<p>CRYENGINE provides a view system, which is a low level means of controlling the view for the player. While you can have several views created and linked to an entity - in the words of Highlander &ldquo;There can only be one&rdquo; when it comes to which view is active. The cameras will need to take turns capturing the view when they activate - and releasing the view when they deactivate.</p>
<p>At this point I don&rsquo;t have any cameras that are not being managed by the camera manager - but when I do I will need to make sure that they play nice and release that view when done, and the camera manager will need to tell the newly re-activated camera it needs to capture the view again.</p>
<p>It might be possible to simply have the view captured by the manager, but I haven&rsquo;t tested that theory as yet.</p>
<p>The following pair of routines will be replicated in each camera, and are called by the camera manager when a camera is changing from active to inactive.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> CFirstPersonCameraComponent<span style=color:#f92672>::</span>OnActivate()
{
	gEnv<span style=color:#f92672>-&gt;</span>pGame<span style=color:#f92672>-&gt;</span>GetIGameFramework()<span style=color:#f92672>-&gt;</span>GetIViewSystem()<span style=color:#f92672>-&gt;</span>SetActiveView(m_pView);
	GetGameObject()<span style=color:#f92672>-&gt;</span>CaptureView(<span style=color:#66d9ef>this</span>);
	GetGameObject()<span style=color:#f92672>-&gt;</span>EnableUpdateSlot(<span style=color:#66d9ef>this</span>, CPlayer<span style=color:#f92672>::</span>EPlayerUpdateSlot<span style=color:#f92672>::</span>ePlayerUpdateSlot_CameraFirstPerson);
}

<span style=color:#66d9ef>void</span> CFirstPersonCameraComponent<span style=color:#f92672>::</span>OnDeactivate()
{
	GetGameObject()<span style=color:#f92672>-&gt;</span>ReleaseView(<span style=color:#66d9ef>this</span>);
	GetGameObject()<span style=color:#f92672>-&gt;</span>DisableUpdateSlot(<span style=color:#66d9ef>this</span>, CPlayer<span style=color:#f92672>::</span>EPlayerUpdateSlot<span style=color:#f92672>::</span>ePlayerUpdateSlot_CameraFirstPerson);
}
</code></pre></div><p>We just need to capture the view when activated and release it when deactivated. On top of that I am enabling / disabling the update function for this entity - and since we have multiple cameras attached to it you should note that I have to select a specific slot for each camera type. If you don&rsquo;t use different slots you will find multiple cameras being updated each cycle - and that&rsquo;s not something you want.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> CFirstPersonCameraComponent<span style=color:#f92672>::</span>UpdateView(SViewParams<span style=color:#f92672>&amp;</span> params)
{
	<span style=color:#75715e>// The last update call should have given us a new updated position and rotation.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// We now pass those off to the view system. 
</span><span style=color:#75715e></span>	params.SaveLast();
	params.position <span style=color:#f92672>=</span> GetCameraPose().GetPosition();
	params.rotation <span style=color:#f92672>=</span> GetCameraPose().GetRotation();

	<span style=color:#75715e>// Apply a last minute offset if available for debugging purposes.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> (m_pCameraManager)
		params.position <span style=color:#f92672>+=</span> GetCameraPose().GetRotation() <span style=color:#f92672>*</span> m_pCameraManager<span style=color:#f92672>-&gt;</span>GetViewOffset();

	<span style=color:#75715e>// For simplicity at present we are just hard coding the FoV.
</span><span style=color:#75715e></span>	params.fov <span style=color:#f92672>=</span> DEG2RAD(<span style=color:#ae81ff>60.0f</span>);
}
</code></pre></div><p>To fully take our place in the world as a provider of view we need to implement the <strong>IGameObjectView</strong> interface and at least the <strong>UpdateView</strong> function. This will be called on the active view and is how the system knows which slice of the world it needs to render in the viewport.</p>
<p>Two things of note: I hard coded the field of view, which is returned from this function because I am lazy and haven&rsquo;t gotten around to writing an implementation yet. My hope is to make one that adapts to the view, opening up if you are gazing off into the distance and narrowing down for nearer targets e.g. conversations with other characters. A shifting field of view during combat would be disastrous if implemented poorly, so it&rsquo;s waiting for another day when I have a better idea of how the whole system works together.</p>
<p>The other thing to note is I am applying the camera manager view offset at this point and each camera will need to do this. It&rsquo;s a bit redundant, but worth it for the debugging potential. Notice the offset is applied in camera space by multiplying the rotation quaternion by the offset vector - returning a vector.</p>
<p>Moving to the Update function now, the core of code that makes this a first person camera.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> CFirstPersonCameraComponent<span style=color:#f92672>::</span>Update(SEntityUpdateContext <span style=color:#f92672>&amp;</span>ctx, <span style=color:#66d9ef>int</span> updateSlot)
{
    <span style=color:#66d9ef>auto</span> pPlayerInput <span style=color:#f92672>=</span> CPlayer<span style=color:#f92672>::</span>GetLocalPlayer()<span style=color:#f92672>-&gt;</span>GetPlayerInput();

    <span style=color:#75715e>// Default on failure is to return a cleanly constructed blank camera pose.
</span><span style=color:#75715e></span>    CCameraPose newCameraPose{CCameraPose()};

    <span style=color:#75715e>// If the player changes the camera zoom, we will toggle to the third person view.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (m_pCameraManager)
    {
        <span style=color:#66d9ef>if</span> ((pPlayerInput<span style=color:#f92672>-&gt;</span>GetZoomDelta() <span style=color:#f92672>&gt;</span> FLT_EPSILON) <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#f92672>!</span>m_pCameraManager<span style=color:#f92672>-&gt;</span>IsThirdPerson()))
            m_pCameraManager<span style=color:#f92672>-&gt;</span>ToggleThirdPerson();
    }

    <span style=color:#75715e>// Resolve the entity.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> pEntity <span style=color:#f92672>=</span> gEnv<span style=color:#f92672>-&gt;</span>pEntitySystem<span style=color:#f92672>-&gt;</span>GetEntity(m_targetEntityID);
    <span style=color:#66d9ef>if</span> (pEntity)
    {
        <span style=color:#75715e>// It&#39;s possible there is no actor to query for eye position, in that case, return a safe default
</span><span style=color:#75715e></span>        <span style=color:#75715e>// value for an average height person.
</span><span style=color:#75715e></span>        Vec3 localEyePosition{AverageEyePosition};

        <span style=color:#75715e>// If we are attached to an entity that is an actor we can use their eye position.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>auto</span> pActor <span style=color:#f92672>=</span> gEnv<span style=color:#f92672>-&gt;</span>pGame<span style=color:#f92672>-&gt;</span>GetIGameFramework()<span style=color:#f92672>-&gt;</span>GetIActorSystem()<span style=color:#f92672>-&gt;</span>GetActor(m_targetEntityID);
        <span style=color:#66d9ef>if</span> (pActor)
            localEyePosition <span style=color:#f92672>=</span> pActor<span style=color:#f92672>-&gt;</span>GetLocalEyePos();

        <span style=color:#75715e>// Apply the player input rotation for this frame, and limit the pitch / yaw movement according to the set max and min values.
</span><span style=color:#75715e></span>        m_viewPitch <span style=color:#f92672>-=</span> pPlayerInput<span style=color:#f92672>-&gt;</span>GetPitchDelta();
        m_viewPitch <span style=color:#f92672>=</span> clamp_tpl(m_viewPitch, DEG2RAD(GetCVars().m_pitchMin), DEG2RAD(GetCVars().m_pitchMax));

        <span style=color:#75715e>// Pose is based on entity position and the eye position.
</span><span style=color:#75715e></span>        <span style=color:#75715e>// We will use the rotation of the entity as a base, and apply pitch based on our own reckoning.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> Vec3 position <span style=color:#f92672>=</span> pEntity<span style=color:#f92672>-&gt;</span>GetPos() <span style=color:#f92672>+</span> localEyePosition;
        <span style=color:#66d9ef>const</span> Quat rotation <span style=color:#f92672>=</span> pEntity<span style=color:#f92672>-&gt;</span>GetRotation() <span style=color:#f92672>*</span> Quat(Ang3(m_viewPitch, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>));
        newCameraPose <span style=color:#f92672>=</span> CCameraPose(position, rotation);

<span style=color:#75715e>#if defined(_DEBUG)
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (GetCVars().m_debug)
        {
            gEnv<span style=color:#f92672>-&gt;</span>pRenderer<span style=color:#f92672>-&gt;</span>GetIRenderAuxGeom()<span style=color:#f92672>-&gt;</span>DrawSphere(position, <span style=color:#ae81ff>0.04f</span>, ColorB(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>));
        }
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    }

    <span style=color:#75715e>// We set the pose, regardless of the result.
</span><span style=color:#75715e></span>    SetCameraPose(newCameraPose);
}
</code></pre></div><p>The Update function needs to take in player input for the frame and attempt to calculate a new position for the camera view. It&rsquo;s possible something might go wrong, so to add some resilience we use a default constructed view - which would be at the 0,0,0 origin pointing in the <strong>IDENTITY</strong> direction. If your camera is showing you at the bottom of the ocean on the corner of the map it&rsquo;s possibly because something went wrong here.</p>
<p>Now, remember, this camera uses another entity, rather than the hosting entity as it&rsquo;s target for the view. The first thing we are doing is to query for that entity and request it&rsquo;s local eye position. Behind the scenes the actor class is going to query the skeleton <strong>and</strong> the animation and determine just exactly where the actor&rsquo;s eyes are during this frame of animation. There are some considerations to take into account for first person views.</p>
<p>If we&rsquo;re standing upright it should all be fine, but if your actor is doubled over vomiting into a toilet then the camera will be rotated relative to the head, so the naive approach we are taking here (which we will get to in a moment) can lead to some weirdness e.g. looking through the back of some head geometry. That&rsquo;s not a problem for the project yet, so it can slide for now.</p>
<p>Having positioned the view at the <strong>#camera</strong> bone on the actor by calling localEyePosition = pActor->GetLocalEyePos(); we need to orient it. We are going for simplicity, so all we are going to do is take the entitity&rsquo;s current rotation as a base and apply a pitch delta to that - so the player controls tilting the camera / head up and down only. That&rsquo;s easily handled by a couple of rotations using quaternions as below:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>const</span> Quat rotation <span style=color:#f92672>=</span> pEntity<span style=color:#f92672>-&gt;</span>GetRotation() <span style=color:#f92672>*</span> Quat(Ang3(m_viewPitch, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>));
</code></pre></div><p>Now, why did I allow a pitch tilt delta and not one for yaw? The answer is that a first person camera should be locked in the direction your actor is facing. Unless you are providing some means for the actor to turn their head independent of the body you can consider their gaze direction as being in lock-step with their entity rotation. That said, you still need to be able to aim up and down, and a pitch delta can provide this. You get bonus points if you allow querying for this delta and then allow the animation system to tilt the avatar&rsquo;s head in time to your camera movements.</p>
<p>The last piece of code which I haven&rsquo;t mentioned is where we query the player input to see if the player requested a change in the zoom level. First person cameras don&rsquo;t need to worry about zoom, but I want to be able to use my mouse scroll button to zoom in and out of first and third person view seamlessly. In order to do that there is a little code in each of those cameras which looks for changes in the zoom and flips the third person toggle when needed. The toggle of the cameras will occur on the next frame, which is fine for this purpose.</p>
<h2 id=the-action-rpg-camera>The Action RPG Camera</h2>
<p>My eventual goal is to create the <strong>Chrysalis</strong> toolkit, which will be an SDK for creating action RPG style games using CRYENGINE. For that I need a freely rotating orbit camera with yaw, pitch and zoom. The camera needs to be smoothly interpolated (both <strong>SLERP</strong> and <strong>LERP</strong>) and should support at least a basic collision detection and mitigation. The camera should support over the shoulder views through cvars, and allow for rotation around the character when motionless to enable taking of &ldquo;selfies&rdquo;. It needs to be controllable enough to allow you to aim spells or weapons at specific targets since I will be using a targetless combat system. It must work in conjunction with the animation system, providing information for aim and look poses.</p>
<p>With those goals stated, let&rsquo;s hit the code to see how it works. Much of the code is shared in common with the first person camera so we will only examine the code that is unique or interesting in this camera.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SExternalCVars</span>
{
	<span style=color:#66d9ef>int</span> m_debug;
	<span style=color:#66d9ef>float</span> m_pitchMin;
	<span style=color:#66d9ef>float</span> m_pitchMax;
	<span style=color:#66d9ef>float</span> m_targetDistance;
	<span style=color:#66d9ef>float</span> m_reversePitchTilt;
	<span style=color:#66d9ef>float</span> m_slerpSpeed;
	<span style=color:#66d9ef>float</span> m_zoomMin;
	<span style=color:#66d9ef>float</span> m_zoomMax;
	<span style=color:#66d9ef>float</span> m_zoomStep;
	<span style=color:#66d9ef>float</span> m_zoomSpeed;
	ICVar<span style=color:#f92672>*</span> m_viewPositionOffset;
	ICVar<span style=color:#f92672>*</span> m_aimPositionOffset;
};
</code></pre></div><p>This camera declares a handful of cvars which you can use to tweak it&rsquo;s positioning. The registration code contains descriptions for each one, but a couple are worthy of discussion here.</p>
<p><strong>m_targetDistance</strong> is simply the maximum range over which the camera may zoom back and forth. You will want to limit this to sensible values to prevent players from making it 2kms and zooming out to see the entire map for instance.</p>
<p>I have added what I tentatively call <strong>m_reversePitchTilt</strong> which is a pitch rotation in the opposite direction to which the main camera is tilting. You will need to play with this value to see what it does. Small values will open up the curve of the orbit somewhat, while large values will tend to flatten it right out - keeping the view facing more directly along the horizon.</p>
<p>The camera makes use of a <strong>SLERP</strong> function to smooth out it&rsquo;s rotations so fast camera panning doesn&rsquo;t make it cut across the orbit instead of cleanly around the outside. You can control the speed at which it does that with <strong>m_slerpSpeed</strong>. <strong>m_zoomSpeed</strong> will provide a similar <strong>LERP</strong> when zooming the camera in and out.</p>
<p>Finally, there is <strong>m_viewPositionOffset</strong> and <strong>m_aimPositionOffset</strong>. These pair of vectors allow you to offset the view and aim positions in the player orientation. They give you the ability to create over the shoulder cameras.</p>
<p>Before we tackle the Update function let&rsquo;s take a look at the pair of functions not seen before in the first person camera.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>Vec3 CActionRPGCameraComponent<span style=color:#f92672>::</span>GetTargetAimPosition(IEntity <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> pEntity)
{
    Vec3 position{AverageEyePosition};

    <span style=color:#66d9ef>if</span> (pEntity)
    {
        <span style=color:#75715e>// If we are attached to an entity that is an actor we can use their eye position.
</span><span style=color:#75715e></span>        Vec3 localEyePosition <span style=color:#f92672>=</span> position;
        <span style=color:#66d9ef>auto</span> pActor <span style=color:#f92672>=</span> gEnv<span style=color:#f92672>-&gt;</span>pGame<span style=color:#f92672>-&gt;</span>GetIGameFramework()<span style=color:#f92672>-&gt;</span>GetIActorSystem()<span style=color:#f92672>-&gt;</span>GetActor(m_targetEntityID);
        <span style=color:#66d9ef>if</span> (pActor)
            localEyePosition <span style=color:#f92672>=</span> pActor<span style=color:#f92672>-&gt;</span>GetLocalEyePos();

        <span style=color:#75715e>// Pose is based on entity position and the eye position.
</span><span style=color:#75715e></span>        <span style=color:#75715e>// We will use the rotation of the entity as a base, and apply pitch based on our own reckoning.
</span><span style=color:#75715e></span>        position <span style=color:#f92672>=</span> pEntity<span style=color:#f92672>-&gt;</span>GetPos() <span style=color:#f92672>+</span> localEyePosition;

<span style=color:#75715e>#if defined(_DEBUG)
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (GetCVars().m_debug)
        {
            gEnv<span style=color:#f92672>-&gt;</span>pRenderer<span style=color:#f92672>-&gt;</span>GetIRenderAuxGeom()<span style=color:#f92672>-&gt;</span>DrawSphere(position, <span style=color:#ae81ff>0.04f</span>, ColorB(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>));
        }
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>return</span> position;
}
</code></pre></div><p>Well, we saw most of that in the Update for the first person camera - it&rsquo;s simply broken out into a function here. I should probably clean up the first person code and make it use a similar function.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>bool</span> CActionRPGCameraComponent<span style=color:#f92672>::</span>CollisionDetection(<span style=color:#66d9ef>const</span> Vec3 <span style=color:#f92672>&amp;</span>Goal, Vec3 <span style=color:#f92672>&amp;</span>CameraPosition)
{
    <span style=color:#66d9ef>bool</span> updatedCameraPosition <span style=color:#f92672>=</span> false;

    <span style=color:#75715e>// Skip the target actor for this.
</span><span style=color:#75715e></span>    ray_hit rayhit;
    <span style=color:#66d9ef>static</span> IPhysicalEntity <span style=color:#f92672>*</span>pSkipEnts[<span style=color:#ae81ff>10</span>];
    pSkipEnts[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> gEnv<span style=color:#f92672>-&gt;</span>pEntitySystem<span style=color:#f92672>-&gt;</span>GetEntity(m_targetEntityID)<span style=color:#f92672>-&gt;</span>GetPhysics();

    <span style=color:#75715e>// Perform the ray cast.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> hits <span style=color:#f92672>=</span> gEnv<span style=color:#f92672>-&gt;</span>pPhysicalWorld<span style=color:#f92672>-&gt;</span>RayWorldIntersection(Goal,
          CameraPosition <span style=color:#f92672>-</span> Goal,
          ent_static <span style=color:#960050;background-color:#1e0010>&#39;</span> ent_sleeping_rigid <span style=color:#960050;background-color:#1e0010>&#39;</span> ent_rigid <span style=color:#960050;background-color:#1e0010>&#39;</span> ent_independent <span style=color:#960050;background-color:#1e0010>&#39;</span> ent_terrain,
          rwi_stop_at_pierceable <span style=color:#960050;background-color:#1e0010>&#39;</span> rwi_colltype_any, <span style=color:#f92672>&amp;</span> rayhit,
          <span style=color:#ae81ff>1</span>, pSkipEnts, <span style=color:#ae81ff>2</span>);

    <span style=color:#66d9ef>if</span> (hits)
    {
        CameraPosition <span style=color:#f92672>=</span> rayhit.pt;
        updatedCameraPosition <span style=color:#f92672>=</span> true;
    }

    <span style=color:#66d9ef>return</span> updatedCameraPosition;
}
</code></pre></div><p>It&rsquo;s inevitable that your camera will be in an untenable position at times, unable to see the player&rsquo;s character because something is in the way. You really don&rsquo;t want the camera to clip through walls, it looks terrible, and isn&rsquo;t a lot better with other characters either - but I haven&rsquo;t had time to write anything fancy yet. For now, a simple collision detection will be enough.</p>
<p>This code just does a raycast from the actor back to the camera&rsquo;s calculated position. If it hits anything solid on the way it crops the camera position down to that raycast hit point. The character physics proxy is added to an ignore list to prevent stupidity from occurring. You should also add any weapons, items, etc to this list once those are implemented.</p>
<p>It&rsquo;s finally time to examine the Update function for this camera - and at about 120 lines it&rsquo;s not small, but it is readable and well commented.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> CActionRPGCameraComponent<span style=color:#f92672>::</span>Update(SEntityUpdateContext <span style=color:#f92672>&amp;</span>ctx, <span style=color:#66d9ef>int</span> updateSlot)
{
    <span style=color:#75715e>// Default on failure is to return a cleanly constructed blank camera pose.
</span><span style=color:#75715e></span>    CCameraPose newCameraPose{CCameraPose()};

    <span style=color:#66d9ef>auto</span> pEntity <span style=color:#f92672>=</span> gEnv<span style=color:#f92672>-&gt;</span>pEntitySystem<span style=color:#f92672>-&gt;</span>GetEntity(m_targetEntityID);
    <span style=color:#66d9ef>auto</span> pPlayerInput <span style=color:#f92672>=</span> CPlayer<span style=color:#f92672>::</span>GetLocalPlayer()<span style=color:#f92672>-&gt;</span>GetPlayerInput();

    <span style=color:#66d9ef>if</span> (pPlayerInput)
    {
        <span style=color:#75715e>// If the player zoomed all the way in, switch to the first person camera.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>float</span> tempZoomGoal <span style=color:#f92672>=</span> m_lastZoomGoal <span style=color:#f92672>+</span> pPlayerInput<span style=color:#f92672>-&gt;</span>GetZoomDelta() <span style=color:#f92672>*</span> GetCVars().m_zoomStep;
        <span style=color:#66d9ef>if</span> (m_pCameraManager)
        {
            <span style=color:#66d9ef>if</span> ((tempZoomGoal <span style=color:#f92672>&lt;</span> GetCVars().m_zoomMin) <span style=color:#f92672>&amp;&amp;</span> (m_pCameraManager<span style=color:#f92672>-&gt;</span>IsThirdPerson()))
                m_pCameraManager<span style=color:#f92672>-&gt;</span>ToggleThirdPerson();
        }

        <span style=color:#75715e>// Calculate the new zoom goal after asking the player input for zoom level deltas.
</span><span style=color:#75715e></span>        m_zoomGoal <span style=color:#f92672>=</span> clamp_tpl(tempZoomGoal, GetCVars().m_zoomMin, GetCVars().m_zoomMax);
        m_lastZoomGoal <span style=color:#f92672>=</span> m_zoomGoal;

        <span style=color:#75715e>// Apply the player input rotation for this frame, and limit the pitch / yaw movement according to the set max and min values.
</span><span style=color:#75715e></span>        m_viewPitch <span style=color:#f92672>+=</span> pPlayerInput<span style=color:#f92672>-&gt;</span>GetPitchDelta();
        m_viewPitch <span style=color:#f92672>=</span> clamp_tpl(m_viewPitch, DEG2RAD(GetCVars().m_pitchMin), DEG2RAD(GetCVars().m_pitchMax));
        m_viewYaw <span style=color:#f92672>+=</span> pPlayerInput<span style=color:#f92672>-&gt;</span>GetYawDelta();

        <span style=color:#75715e>// Yaw should wrap around if it exceeds it&#39;s values. This is a bit simplistic, but will work most of the time.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (m_viewYaw <span style=color:#f92672>&gt;</span> g_PI)
            m_viewYaw <span style=color:#f92672>-=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span>(g_PI2);
        <span style=color:#66d9ef>if</span> (m_viewYaw <span style=color:#f92672>&lt;</span> <span style=color:#f92672>-</span>g_PI)
            m_viewYaw <span style=color:#f92672>+=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span>(g_PI2);

        <span style=color:#75715e>// Skip the update if we don&#39;t need to process the movement. Whenever we skip over frames we have to also skip
</span><span style=color:#75715e></span>        <span style=color:#75715e>// running interpolation for the following frame.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> ((pEntity) <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#f92672>!</span>gEnv<span style=color:#f92672>-&gt;</span>IsCutscenePlaying()))
        {
            <span style=color:#75715e>// Interpolate towards the desired zoom position.
</span><span style=color:#75715e></span>            Interpolate(m_zoom, m_zoomGoal, GetCVars().m_zoomSpeed, ctx.fFrameTime);

            <span style=color:#75715e>// Get the entity we are targeting.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>auto</span> pTargetEntity <span style=color:#f92672>=</span> gEnv<span style=color:#f92672>-&gt;</span>pEntitySystem<span style=color:#f92672>-&gt;</span>GetEntity(m_targetEntityID);
            <span style=color:#66d9ef>if</span> (pTargetEntity)
            {
                <span style=color:#75715e>// Calculate pitch and yaw movements to apply both prior to and after positioning the camera.
</span><span style=color:#75715e></span>                Quat quatPreTransYP <span style=color:#f92672>=</span> Quat(Ang3(m_viewPitch, <span style=color:#ae81ff>0.0f</span>, m_viewYaw));
                Quat quatPostTransYP <span style=color:#f92672>=</span> Quat<span style=color:#f92672>::</span>CreateRotationXYZ(Ang3(m_viewPitch <span style=color:#f92672>*</span> GetCVars().m_reversePitchTilt, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>));

                <span style=color:#75715e>// Target and aim position come from the entity position.
</span><span style=color:#75715e></span>                Vec3 vecTargetAimPosition <span style=color:#f92672>=</span> GetTargetAimPosition(pTargetEntity);

                <span style=color:#75715e>// The distance from the view to the target.
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>float</span> shapedZoom <span style=color:#f92672>=</span> (m_zoom <span style=color:#f92672>*</span> m_zoom) <span style=color:#f92672>/</span> (GetCVars().m_zoomMax <span style=color:#f92672>*</span> GetCVars().m_zoomMax);
                <span style=color:#66d9ef>float</span> zoomDistance <span style=color:#f92672>=</span> GetCVars().m_targetDistance <span style=color:#f92672>*</span> shapedZoom;

                <span style=color:#75715e>// Calculate the target rotation and slerp it if we can.
</span><span style=color:#75715e></span>                Quat quatTargetRotationGoal <span style=color:#f92672>=</span> m_quatTargetRotation <span style=color:#f92672>*</span> quatPreTransYP;
                Quat quatTargetRotation;
                <span style=color:#66d9ef>if</span> (m_skipInterpolation)
                {
                    m_quatLastTargetRotation <span style=color:#f92672>=</span> quatTargetRotation <span style=color:#f92672>=</span> quatTargetRotationGoal;
                }
                <span style=color:#66d9ef>else</span>
                {
                    quatTargetRotation <span style=color:#f92672>=</span> Quat<span style=color:#f92672>::</span>CreateSlerp(m_quatLastTargetRotation, quatTargetRotationGoal, ctx.fFrameTime <span style=color:#f92672>*</span> GetCVars().m_slerpSpeed);
                    m_quatLastTargetRotation <span style=color:#f92672>=</span> quatTargetRotation;
                }

                <span style=color:#75715e>// Work out where to place the new initial position. We will be using a unit vector facing forward Y
</span><span style=color:#75715e></span>                <span style=color:#75715e>// as the starting place and applying rotations from the target bone and player camera movements.
</span><span style=color:#75715e></span>                Vec3 viewPositionOffset <span style=color:#f92672>=</span> Vec3FromString(GetCVars().m_viewPositionOffset<span style=color:#f92672>-&gt;</span>GetString());
                Vec3 vecViewPosition <span style=color:#f92672>=</span> vecTargetAimPosition <span style=color:#f92672>+</span> (quatTargetRotation <span style=color:#f92672>*</span> (Vec3(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0.0f</span>) <span style=color:#f92672>*</span> zoomDistance)) <span style=color:#f92672>+</span> quatTargetRotation <span style=color:#f92672>*</span> viewPositionOffset;

                <span style=color:#75715e>// By default, we try and aim the camera at the target, taking into account the current mouse yaw and pitch values.
</span><span style=color:#75715e></span>                <span style=color:#75715e>// Since the target and aim can actually be the same we need to use a safe version of the normalised quaternion to
</span><span style=color:#75715e></span>                <span style=color:#75715e>// prevent errors.
</span><span style=color:#75715e></span>                Quat quatViewRotationGoal <span style=color:#f92672>=</span> Quat<span style=color:#f92672>::</span>CreateRotationVDir((vecTargetAimPosition <span style=color:#f92672>-</span> vecViewPosition).GetNormalizedSafe());

                <span style=color:#75715e>// Use a slerp to smooth out fast camera rotations.
</span><span style=color:#75715e></span>                Quat quatViewRotation;
                <span style=color:#66d9ef>if</span> (m_skipInterpolation)
                {
                    m_quatLastViewRotation <span style=color:#f92672>=</span> quatViewRotation <span style=color:#f92672>=</span> quatViewRotationGoal;
                    m_skipInterpolation <span style=color:#f92672>=</span> false;
                }
                <span style=color:#66d9ef>else</span>
                {
                    quatViewRotation <span style=color:#f92672>=</span> Quat<span style=color:#f92672>::</span>CreateSlerp(m_quatLastViewRotation, quatViewRotationGoal, ctx.fFrameTime <span style=color:#f92672>*</span> GetCVars().m_slerpSpeed);
                    m_quatLastViewRotation <span style=color:#f92672>=</span> quatViewRotation;
                }

                <span style=color:#75715e>// Apply a final translation to both the view position and the aim position.
</span><span style=color:#75715e></span>                Vec3 aimPositionOffset <span style=color:#f92672>=</span> Vec3FromString(GetCVars().m_aimPositionOffset<span style=color:#f92672>-&gt;</span>GetString());
                vecViewPosition <span style=color:#f92672>+=</span> quatViewRotation <span style=color:#f92672>*</span> aimPositionOffset;

                <span style=color:#75715e>// Gimbal style rotation after it&#39;s moved into it&#39;s initial position.
</span><span style=color:#75715e></span>                Quat quatOrbitRotation <span style=color:#f92672>=</span> quatViewRotation <span style=color:#f92672>*</span> quatPostTransYP;

                <span style=color:#75715e>// Perform a collision detection. Note, any collisions will disallow use of interpolated camera movement.
</span><span style=color:#75715e></span>                CollisionDetection(vecTargetAimPosition, vecViewPosition);

<span style=color:#75715e>#if defined(_DEBUG)
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (GetCVars().m_debug)
                {
                    gEnv<span style=color:#f92672>-&gt;</span>pRenderer<span style=color:#f92672>-&gt;</span>GetIRenderAuxGeom()<span style=color:#f92672>-&gt;</span>DrawSphere(vecTargetAimPosition, <span style=color:#ae81ff>0.04f</span>, ColorB(<span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>));
                    gEnv<span style=color:#f92672>-&gt;</span>pRenderer<span style=color:#f92672>-&gt;</span>GetIRenderAuxGeom()<span style=color:#f92672>-&gt;</span>DrawSphere(vecTargetAimPosition <span style=color:#f92672>+</span> quatTargetRotation <span style=color:#f92672>*</span> viewPositionOffset, <span style=color:#ae81ff>0.04f</span>, ColorB(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>0</span>));
                }
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
                <span style=color:#75715e>// Track our last position.
</span><span style=color:#75715e></span>                m_vecLastPosition <span style=color:#f92672>=</span> vecViewPosition;

                <span style=color:#75715e>// Return the newly calculated pose.
</span><span style=color:#75715e></span>                newCameraPose <span style=color:#f92672>=</span> CCameraPose(vecViewPosition, quatOrbitRotation);
                SetCameraPose(newCameraPose);

                <span style=color:#66d9ef>return</span>;
            }
        }
    }

    <span style=color:#75715e>// We set the pose, regardless of the result.
</span><span style=color:#75715e></span>    SetCameraPose(newCameraPose);

    <span style=color:#75715e>// If we made it here, we will want to avoid interpolating, since the last frame result will be wrong in some way.
</span><span style=color:#75715e></span>    m_skipInterpolation <span style=color:#f92672>=</span> true;
}
</code></pre></div><p>It starts with grabbing a few pointers to often used data and a quick check to see if it needs to switch to the first person view in the next frame thanks to changes in the zoom level.</p>
<p>The camera then needs to start calculating a new goal for it&rsquo;s position. The goal is based on two things, the desired level of zoom and the desired rotation. We don&rsquo;t allow the camera to just snap straight to the new position, it&rsquo;s jarring and looks janky. We need to carefully select the new position as a goal and then interpolate towards it.</p>
<p>We do this by querying the player input for this frame, grab the deltas in yaw, pitch, roll and zoom, clamp them and make sure they get cropped and wrap around correctly. Once everything is clamped we can start to use the values.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Interpolate towards the desired zoom position.
</span><span style=color:#75715e></span>Interpolate(m_zoom, m_zoomGoal, GetCVars().m_zoomSpeed, ctx.fFrameTime);
</code></pre></div><p>We take the zoom goal and start to interpolate towards it. This will run over as many frames as it takes to eventually reach that goal. If your zoom speed is sufficiently slow you can see the camera lazily zooming in and out.</p>
<p>Next in line is a bunch of code doing strange rotations with quaternions. It&rsquo;s easy to get lost in all those transformations so take it slow.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Calculate pitch and yaw movements to apply both prior to and after positioning the camera.
</span><span style=color:#75715e></span>Quat quatPreTransYP <span style=color:#f92672>=</span> Quat(Ang3(m_viewPitch, <span style=color:#ae81ff>0.0f</span>, m_viewYaw));
Quat quatPostTransYP <span style=color:#f92672>=</span> Quat<span style=color:#f92672>::</span>CreateRotationXYZ(Ang3(m_viewPitch <span style=color:#f92672>*</span> GetCVars().m_reversePitchTilt, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>));
</code></pre></div><p>It makes sense for an action RRPG camera to handle yaw and pitch, but not roll - so you won&rsquo;t see roll used anywhere in these transformations and you should note I factor it out when creating the quaternions. These two will be used <strong>before</strong> and <strong>after</strong> we apply any translations to the camera &ldquo;PreTrans&rdquo; being short for pre-translation. Notice the reverse pitch tilt will be factored in after the camera is translated into position.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Target and aim position come from the entity position.
</span><span style=color:#75715e></span>Vec3 vecTargetAimPosition <span style=color:#f92672>=</span> GetTargetAimPosition(pTargetEntity);
</code></pre></div><p>Here we are querying the actor for the position that will be the very centre of our orbit. I&rsquo;ll be using the eyes as the target, adjusted for the currently playing animation.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// The distance from the view to the target.
</span><span style=color:#75715e></span><span style=color:#66d9ef>float</span> shapedZoom <span style=color:#f92672>=</span> (m_zoom <span style=color:#f92672>*</span> m_zoom) <span style=color:#f92672>/</span> (GetCVars().m_zoomMax <span style=color:#f92672>*</span> GetCVars().m_zoomMax);
<span style=color:#66d9ef>float</span> zoomDistance <span style=color:#f92672>=</span> GetCVars().m_targetDistance <span style=color:#f92672>*</span> shapedZoom;
</code></pre></div><p>I wanted a zoom function that wasn&rsquo;t linear. I wanted it to give smaller steps as you came closer to the actor, and larger ones the further you zoomed out. These calculations provide a decent enough non-linear zoom for my purposes.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Calculate the target rotation and slerp it if we can.
</span><span style=color:#75715e></span>Quat quatTargetRotationGoal <span style=color:#f92672>=</span> m_quatTargetRotation <span style=color:#f92672>*</span> quatPreTransYP;
Quat quatTargetRotation;
<span style=color:#66d9ef>if</span> (m_skipInterpolation)
{
	m_quatLastTargetRotation <span style=color:#f92672>=</span> quatTargetRotation <span style=color:#f92672>=</span> quatTargetRotationGoal;
}
<span style=color:#66d9ef>else</span>
{
	quatTargetRotation <span style=color:#f92672>=</span> Quat<span style=color:#f92672>::</span>CreateSlerp(m_quatLastTargetRotation, quatTargetRotationGoal, ctx.fFrameTime <span style=color:#f92672>*</span> GetCVars().m_slerpSpeed);
	m_quatLastTargetRotation <span style=color:#f92672>=</span> quatTargetRotation;
}
</code></pre></div><p>Once again we need to interpolate towards a target, but in this case, since the target is a rotation we can&rsquo;t just use a simple linear interpolation we need a spherical interpolation. There&rsquo;s a slight wrinkle though. We have to check for conditions from the last frame that might cause us to need to jump immediately to the target position and rotation - one obvious case being if we had to move due to collision detection.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Work out where to place the new initial position. We will be using a unit vector facing forward Y
</span><span style=color:#75715e>// as the starting place and applying rotations from the target bone and player camera movements.
</span><span style=color:#75715e></span>Vec3 viewPositionOffset <span style=color:#f92672>=</span> Vec3FromString(GetCVars().m_viewPositionOffset<span style=color:#f92672>-&gt;</span>GetString());
Vec3 vecViewPosition <span style=color:#f92672>=</span> vecTargetAimPosition <span style=color:#f92672>+</span> (quatTargetRotation <span style=color:#f92672>*</span> (Vec3(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0.0f</span>) <span style=color:#f92672>*</span> zoomDistance))
	<span style=color:#f92672>+</span> quatTargetRotation <span style=color:#f92672>*</span> viewPositionOffset;
</code></pre></div><p>At this point we&rsquo;re trying to calculate the view position, given the zoom length, the aim position (centre of orbit), the entity&rsquo;s rotation and finally an offset of that view position (for over the shoulder views).</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// By default, we try and aim the camera at the target, taking into account the current mouse yaw and pitch values.
</span><span style=color:#75715e>// Since the target and aim can actually be the same we need to use a safe version of the normalised quaternion to
</span><span style=color:#75715e>// prevent errors.
</span><span style=color:#75715e></span>Quat quatViewRotationGoal <span style=color:#f92672>=</span> Quat<span style=color:#f92672>::</span>CreateRotationVDir((vecTargetAimPosition <span style=color:#f92672>-</span> vecViewPosition).GetNormalizedSafe());
</code></pre></div><p>By subtracting the view position from the aim position we can work out a rotation that represents the camera looking at the centre of the orbit rotation (or close, after our offsets have been applied).</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Use a slerp to smooth out fast camera rotations.
</span><span style=color:#75715e></span>Quat quatViewRotation;
<span style=color:#66d9ef>if</span> (m_skipInterpolation)
{
	m_quatLastViewRotation <span style=color:#f92672>=</span> quatViewRotation <span style=color:#f92672>=</span> quatViewRotationGoal;
	m_skipInterpolation <span style=color:#f92672>=</span> false;
}
<span style=color:#66d9ef>else</span>
{
	quatViewRotation <span style=color:#f92672>=</span> Quat<span style=color:#f92672>::</span>CreateSlerp(m_quatLastViewRotation, quatViewRotationGoal, ctx.fFrameTime <span style=color:#f92672>*</span> GetCVars().m_slerpSpeed);
	m_quatLastViewRotation <span style=color:#f92672>=</span> quatViewRotation;
}
</code></pre></div><p>If we don&rsquo;t need to skip interpolation then it&rsquo;s time to apply a <strong>SLERP</strong> to the view rotation which will eventually step us to our goal rotation. Again, this might take several frames to reach the goal after you stop rotating the camera view.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Apply a final translation to both the view position and the aim position.
</span><span style=color:#75715e></span>Vec3 aimPositionOffset <span style=color:#f92672>=</span> Vec3FromString(GetCVars().m_aimPositionOffset<span style=color:#f92672>-&gt;</span>GetString());
vecViewPosition <span style=color:#f92672>+=</span> quatViewRotation <span style=color:#f92672>*</span> aimPositionOffset;
</code></pre></div><p>It&rsquo;s time to get our aim offset into play. This is added near the end and is applied in view space for our camera. This gives you a chance to offset the aim position somewhat.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Gimbal style rotation after it&#39;s moved into it&#39;s initial position.
</span><span style=color:#75715e></span>Quat quatOrbitRotation <span style=color:#f92672>=</span> quatViewRotation <span style=color:#f92672>*</span> quatPostTransYP;
</code></pre></div><p>The post translation rotation finally gets applied - this is the one that can reverse tilt the pitch, or indeed anything you wish to add as a final rotation.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Perform a collision detection. Note, any collisions will disallow use of interpolated camera movement.
</span><span style=color:#75715e></span>CollisionDetection(vecTargetAimPosition, vecViewPosition);
</code></pre></div><p>With all those rotations and translation we take the opportunity to crop it if it collides with solid geometry to prevent you seeing through walls.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Track our last position.
</span><span style=color:#75715e></span>m_vecLastPosition <span style=color:#f92672>=</span> vecViewPosition;

<span style=color:#75715e>// Return the newly calculated pose.
</span><span style=color:#75715e></span>newCameraPose <span style=color:#f92672>=</span> CCameraPose(vecViewPosition, quatOrbitRotation);
SetCameraPose(newCameraPose);
</code></pre></div><p>That&rsquo;s it, just return the calculated pose and we&rsquo;re done!</p>
<h2 id=final-thoughts>Final Thoughts</h2>
<p>All code has room for improvement and most needs some adapting for your own uses. I hope that this breakdown of the camera code helps you create your own custom cameras that suit your needs perfectly.</p>
<p>Much of the code has been refactored from the <strong>CRYENGINE GameSDK</strong> and some is from the new c++ game templates and is licensed by <strong>CryTek</strong>. Code that is written by myself is free for re-use in your own projects without limitation or restriction.</p>
<p>The complete code for <a href=https://github.com/ivanhawkes/Chrysalis>Chrysalis</a> is on <a href=https://github.com/>GitHub</a> and the code presented in this article is <a href=https://github.com/ivanhawkes/Chrysalis/tree/camera_code_article>tagged in my repository</a>. My repository is the live code that I am working on and is not recommended for anything beyond teaching purposes. It is subject to change at any time and is unsupported at this time. It has specific needs in terms of assets and project files and those are not published as yet. It should work very well with any of the c++ game templates assets - but this is untested and some code changes will be needed - particularly in regard to character models and animations.</p>
<p>And finally, if you do build Chrysalis and try and test the camera code you will want to update your defaultprofile.xml, since that is where all the keybinds are defined - and they differ from the c++ game template examples. My current file looks like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;profile</span> <span style=color:#a6e22e>version=</span><span style=color:#e6db74>&#34;76&#34;</span><span style=color:#f92672>&gt;</span>

    <span style=color:#75715e>&lt;!-- platforms - Used to define which keys to map for each action based on the platform that is in use --&gt;</span>
    <span style=color:#f92672>&lt;platforms&gt;</span>
        <span style=color:#f92672>&lt;PC</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>xboxpad=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>ps4pad=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>oculustouch=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;XboxOne</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>xboxpad=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>ps4pad=</span><span style=color:#e6db74>&#34;0&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;PS4</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>xboxpad=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>ps4pad=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>/&gt;</span>
    <span style=color:#f92672>&lt;/platforms&gt;</span>

    <span style=color:#75715e>&lt;!--DO NOT REMOVE DEFAULT ACTIONMAP! NEEDED BY CRYACTION.--&gt;</span>
    <span style=color:#f92672>&lt;actionmap</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;default&#34;</span> <span style=color:#a6e22e>version=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>/&gt;</span>
    <span style=color:#75715e>&lt;!----&gt;</span>

    <span style=color:#f92672>&lt;actionmap</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;player&#34;</span><span style=color:#f92672>&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;move_left&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>retriggerable=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>&gt;</span>
            <span style=color:#f92672>&lt;keyboard</span> <span style=color:#a6e22e>input=</span><span style=color:#e6db74>&#34;a&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;/action&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;move_right&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>retriggerable=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>&gt;</span>
            <span style=color:#f92672>&lt;keyboard</span> <span style=color:#a6e22e>input=</span><span style=color:#e6db74>&#34;d&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;/action&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;move_forward&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>retriggerable=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>&gt;</span>
            <span style=color:#f92672>&lt;keyboard</span> <span style=color:#a6e22e>input=</span><span style=color:#e6db74>&#34;w&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;/action&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;move_backward&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>retriggerable=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>&gt;</span>
            <span style=color:#f92672>&lt;keyboard</span> <span style=color:#a6e22e>input=</span><span style=color:#e6db74>&#34;s&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;/action&gt;</span>

        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;move_jump&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;space&#34;</span> <span style=color:#a6e22e>xboxpad=</span><span style=color:#e6db74>&#34;xi_a&#34;</span> <span style=color:#a6e22e>ps3pad=</span><span style=color:#e6db74>&#34;pad_cross&#34;</span> <span style=color:#a6e22e>wiipad=</span><span style=color:#e6db74>&#34;wii_pad_b&#34;</span><span style=color:#f92672>/&gt;</span>

        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;move_walkrun&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>retriggerable=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;n&#34;</span> <span style=color:#a6e22e>xboxpad=</span><span style=color:#e6db74>&#34;xi_thumbl&#34;</span> <span style=color:#a6e22e>ps3pad=</span><span style=color:#e6db74>&#34;pad_l3&#34;</span> <span style=color:#a6e22e>wiipad=</span><span style=color:#e6db74>&#34;wii_pad_l3&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;move_sprint&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>retriggerable=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;lshift&#34;</span> <span style=color:#a6e22e>xboxpad=</span><span style=color:#e6db74>&#34;xi_thumbl&#34;</span> <span style=color:#a6e22e>ps3pad=</span><span style=color:#e6db74>&#34;pad_l3&#34;</span> <span style=color:#a6e22e>wiipad=</span><span style=color:#e6db74>&#34;wii_pad_l3&#34;</span><span style=color:#f92672>/&gt;</span>

        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;stance_crouch&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>retriggerable=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;c&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;stance_kneel&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>retriggerable=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;v&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;stance_sit&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>retriggerable=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;b&#34;</span><span style=color:#f92672>/&gt;</span>

        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;item_use&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>&gt;</span>
            <span style=color:#f92672>&lt;keyboard</span> <span style=color:#a6e22e>input=</span><span style=color:#e6db74>&#34;f&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#f92672>/&gt;</span>
            <span style=color:#f92672>&lt;xboxpad</span> <span style=color:#a6e22e>input=</span><span style=color:#e6db74>&#34;xi_x&#34;</span> <span style=color:#a6e22e>onHold=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>holdTriggerDelay=</span><span style=color:#e6db74>&#34;0.3&#34;</span> <span style=color:#a6e22e>holdRepeatDelay=</span><span style=color:#e6db74>&#34;-1&#34;</span> <span style=color:#f92672>/&gt;</span>
            <span style=color:#f92672>&lt;ps3pad</span> <span style=color:#a6e22e>input=</span><span style=color:#e6db74>&#34;pad_square&#34;</span> <span style=color:#a6e22e>onHold=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>holdTriggerDelay=</span><span style=color:#e6db74>&#34;0.3&#34;</span> <span style=color:#a6e22e>holdRepeatDelay=</span><span style=color:#e6db74>&#34;-1&#34;</span> <span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;/action&gt;</span>

        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;item_pickup&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;j&#34;</span><span style=color:#f92672>/&gt;</span>

        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;actionbar_01&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;actionbar_02&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;2&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;actionbar_03&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;3&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;actionbar_04&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;4&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;actionbar_05&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;5&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;actionbar_06&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;6&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;actionbar_07&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;7&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;actionbar_08&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;8&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;actionbar_09&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;9&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;actionbar_10&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;0&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;actionbar_11&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;minus&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;actionbar_12&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;equals&#34;</span><span style=color:#f92672>/&gt;</span>

        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;tpv_zoom_in&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;mwheel_up&#34;</span> <span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;tpv_zoom_out&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;mwheel_down&#34;</span> <span style=color:#f92672>/&gt;</span>

        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;mouse_rotateyaw&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;maxis_x&#34;</span> <span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;mouse_rotatepitch&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;maxis_y&#34;</span> <span style=color:#f92672>/&gt;</span>

        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;hmd_rotateyaw&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;HMD_Yaw&#34;</span> <span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;hmd_rotatepitch&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;HMD_Pitch&#34;</span> <span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;hmd_rotateroll&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;HMD_Roll&#34;</span> <span style=color:#f92672>/&gt;</span>

        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;xi_movex&#34;</span> <span style=color:#a6e22e>xboxpad=</span><span style=color:#e6db74>&#34;xi_thumblx&#34;</span> <span style=color:#a6e22e>ps3pad=</span><span style=color:#e6db74>&#34;pad_sticklx&#34;</span> <span style=color:#a6e22e>wiipad=</span><span style=color:#e6db74>&#34;wii_pad_sticklx&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;xi_movey&#34;</span> <span style=color:#a6e22e>xboxpad=</span><span style=color:#e6db74>&#34;xi_thumbly&#34;</span> <span style=color:#a6e22e>ps3pad=</span><span style=color:#e6db74>&#34;pad_stickly&#34;</span> <span style=color:#a6e22e>wiipad=</span><span style=color:#e6db74>&#34;wii_pad_stickly&#34;</span><span style=color:#f92672>/&gt;</span>

        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;xi_rotateyaw&#34;</span> <span style=color:#a6e22e>xboxpad=</span><span style=color:#e6db74>&#34;xi_thumbrx&#34;</span> <span style=color:#a6e22e>ps3pad=</span><span style=color:#e6db74>&#34;pad_stickrx&#34;</span> <span style=color:#a6e22e>wiipad=</span><span style=color:#e6db74>&#34;wii_pad_stickrx&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;xi_rotatepitch&#34;</span> <span style=color:#a6e22e>xboxpad=</span><span style=color:#e6db74>&#34;xi_thumbry&#34;</span> <span style=color:#a6e22e>ps3pad=</span><span style=color:#e6db74>&#34;pad_stickry&#34;</span> <span style=color:#a6e22e>wiipad=</span><span style=color:#e6db74>&#34;wii_pad_stickry&#34;</span><span style=color:#f92672>/&gt;</span>
    <span style=color:#f92672>&lt;/actionmap&gt;</span>

    <span style=color:#f92672>&lt;actionmap</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;camera&#34;</span><span style=color:#f92672>&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;camera_shift_up&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onHold=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>holdTriggerDelay=</span><span style=color:#e6db74>&#34;0.20&#34;</span> <span style=color:#a6e22e>holdRepeatDelay=</span><span style=color:#e6db74>&#34;0.05&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;pgup&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;camera_shift_down&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onHold=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>holdTriggerDelay=</span><span style=color:#e6db74>&#34;0.20&#34;</span> <span style=color:#a6e22e>holdRepeatDelay=</span><span style=color:#e6db74>&#34;0.05&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;pgdn&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;camera_shift_left&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onHold=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>holdTriggerDelay=</span><span style=color:#e6db74>&#34;0.20&#34;</span> <span style=color:#a6e22e>holdRepeatDelay=</span><span style=color:#e6db74>&#34;0.05&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;left&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;camera_shift_right&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onHold=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>holdTriggerDelay=</span><span style=color:#e6db74>&#34;0.20&#34;</span> <span style=color:#a6e22e>holdRepeatDelay=</span><span style=color:#e6db74>&#34;0.05&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;right&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;camera_shift_forward&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onHold=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>holdTriggerDelay=</span><span style=color:#e6db74>&#34;0.20&#34;</span> <span style=color:#a6e22e>holdRepeatDelay=</span><span style=color:#e6db74>&#34;0.05&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;up&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;action</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;camera_shift_backward&#34;</span> <span style=color:#a6e22e>onPress=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onRelease=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>onHold=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>holdTriggerDelay=</span><span style=color:#e6db74>&#34;0.20&#34;</span> <span style=color:#a6e22e>holdRepeatDelay=</span><span style=color:#e6db74>&#34;0.05&#34;</span> <span style=color:#a6e22e>keyboard=</span><span style=color:#e6db74>&#34;down&#34;</span><span style=color:#f92672>/&gt;</span>
    <span style=color:#f92672>&lt;/actionmap&gt;</span>

    <span style=color:#f92672>&lt;controllerlayouts&gt;</span>
        <span style=color:#f92672>&lt;layout</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;buttonlayout_alt&#34;</span> <span style=color:#a6e22e>file=</span><span style=color:#e6db74>&#34;buttonlayout_alt.xml&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;layout</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;buttonlayout_altlefty&#34;</span> <span style=color:#a6e22e>file=</span><span style=color:#e6db74>&#34;buttonlayout_altlefty.xml&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;layout</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;buttonlayout_default&#34;</span> <span style=color:#a6e22e>file=</span><span style=color:#e6db74>&#34;buttonlayout_default.xml&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;layout</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;buttonlayout_lefty&#34;</span> <span style=color:#a6e22e>file=</span><span style=color:#e6db74>&#34;buttonlayout_lefty.xml&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;layout</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;sticklayout_default&#34;</span> <span style=color:#a6e22e>file=</span><span style=color:#e6db74>&#34;sticklayout_default.xml&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;layout</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;sticklayout_lefty&#34;</span> <span style=color:#a6e22e>file=</span><span style=color:#e6db74>&#34;sticklayout_lefty.xml&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;layout</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;sticklayout_legacy&#34;</span> <span style=color:#a6e22e>file=</span><span style=color:#e6db74>&#34;sticklayout_legacy.xml&#34;</span><span style=color:#f92672>/&gt;</span>
        <span style=color:#f92672>&lt;layout</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;sticklayout_legacylefty&#34;</span> <span style=color:#a6e22e>file=</span><span style=color:#e6db74>&#34;sticklayout_legacylefty.xml&#34;</span><span style=color:#f92672>/&gt;</span>
    <span style=color:#f92672>&lt;/controllerlayouts&gt;</span>
<span style=color:#f92672>&lt;/profile&gt;</span>
</code></pre></div>
</div>
</div>
<div class=row>
<div class=col-12>
<hr>
</div>
</div>
<div class=row>
<div class=col>
<p class=h6>
Discover more posts like this:
</p>
<p class=h6>
<a class="btn btn-primary" href=/tags/c>
C#
</a>
<a class="btn btn-primary" href=/tags/c++>
C++
</a>
<a class="btn btn-primary" href=/tags/camera-code>
Camera Code
</a>
<a class="btn btn-primary" href=/tags/chrysalis>
Chrysalis
</a>
<a class="btn btn-primary" href=/tags/cryengine-5.2>
CRYENGINE 5.2
</a>
<a class="btn btn-primary" href=/tags/game-programming>
Game Programming
</a>
<a class="btn btn-primary" href=/tags/mathematics>
Mathematics
</a>
</p>
</div>
</div>
<div class=row>
<div class=col>
<hr>
</div>
</div>
<div class=row>
<div class="col-6 text-start">
Previous:<br><a href=https://ivanhawkes.github.io/post/controlling-an-animated-character-in-cryengine-using-cpp/> Controlling an Animated Character in CRYENGINE using C++</a>
</div>
<div class="col-6 text-end">
Next:<br><a href=https://ivanhawkes.github.io/post/switching-to-cryengine-5-3-new-entity-system/> Switching to CRYENGINE 5.3 New Entity System</a>
</div>
</div>
</div>
</div>
<footer>
<div class=row>
<div class=col>
<hr>
</div>
</div>
<nav class="navbar navbar-expand-lg">
<div class=container-fluid>
&copy; 2021 Ivan Hawkes all rights reserved.
</div>
</nav>
</footer>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css integrity=sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3 crossorigin=anonymous>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js integrity=sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM crossorigin=anonymous></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.0/font/bootstrap-icons.css integrity=sha384-7ynz3n3tAGNUYFZD3cWe5PDcE36xj85vyFkawcF6tIwxvIecqKvfwLiaFdizhPpN crossorigin=anonymous>
<link rel=stylesheet type=text/css href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:400,700|Material+Icons">
</body>
</html>